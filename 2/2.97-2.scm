(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  false))
            false)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation - TABLE" m))))
    dispatch))

(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))

(define (put-coercion source-type target-type proc)
  (put 'coercion (list source-type target-type) proc))
(define (get-coercion source-type target-type)
  (get 'coercion (list source-type target-type)))

(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (let ((t1->t2 (get-coercion type1 type2))
                      (t2->t1 (get-coercion type2 type1)))
                  (cond (t1->t2
                         (apply-generic op (t1->t2 a1) a2))
                        (t2->t1
                         (apply-generic op a1 (t2->t1 a2)))
                        (else
                         (error "No method for these types"
                                (list op type-tags))))))
              (error "No method for these types"
                     (list op type-tags)))))))

(define (type-tag datum)
  (cond ((pair? datum) (car datum))
        ((number? datum) 'scheme-number)
        (else (error "Bad tagged datum -- TYPE-TAG" datum))))
(define (contents datum)
  (cond ((pair? datum) (cdr datum))
        ((number? datum) datum)
        (else (error "Bad tagged datum -- CONTENTS" datum))))
(define (attach-tag type-tag contents)
  (if (number? contents)
      contents
      (cons type-tag contents)))

(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (negation x) (apply-generic 'negation x))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (equ? x y) (apply-generic 'equ? x y))
(define (=zero? x) (apply-generic '=zero? x))
(define (greatest-common-divisor x y) (apply-generic 'gcd x y))
(define (reduce x y) (apply-generic 'reduce x y))

;; scheme number package
(define (install-scheme-number-package)
  (define (tag x)
    (attach-tag 'scheme-number x))
  (define (reduce-integers n d)
    (let ((g (gcd n d)))
      (list (/ n g) (/ d g))))
  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'negation '(scheme-number)
       (lambda (x) (tag (- x))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'equ? '(scheme-number scheme-number) =)
  (put '=zero? '(scheme-number)
       (lambda (x) (= x 0)))
  (put 'make 'scheme-number
       (lambda (x) (tag x)))
  (put 'reduce '(scheme-number scheme-number)
       (lambda (n d)
         (let ((new-nd (reduce-integers n d)))
           (list (tag (car new-nd))
                 (tag (cadr new-nd))))))
  'done)
(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))

(define (install-rational-package)
  ;; internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (let ((new-n-d (reduce n d)))
      (cons (car new-n-d) (cadr new-n-d))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  (define (equ-rat x y)
    (and (= (numer x) (numer y))
         (= (denom x) (denom y))))
  ;; interface to rest of the system
  (define (tag x) (attach-tag 'rational x))
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'negation '(rational)
       (lambda (x) (tag (make-rat (- (numer x))
                                  (denom x)))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'sqrt-g '(rational)
       (lambda (x) (div (numer x) (denom x))))
  (put 'square-g '(rational)
       (lambda (x) 
         (tag (make-rat (square (numer x))
                        (square (denom x))))))
  (put 'sine '(rational)
       (lambda (x) (sine (/ (numer x) (denom x)))))
  (put 'cosine '(rational)
       (lambda (x) (cosine (/ (numer x) (denom x)))))
  (put 'atangent '(rational rational)
       (lambda (x y) (atangent (/ (numer x) (denom x))
                               (/ (numer y) (denom y)))))
  (put '=zero? '(rational)
       (lambda (x) (= (numer x) 0)))
  (put 'equ? '(rational rational) equ-rat)
  (put 'raise '(rational)
       (lambda (r)
         (make-scheme-number (exact->inexact (/ (numer r) (denom r))))))
  (put 'project '(rational)
       (lambda (r)
         (make-scheme-number
          (integer-round (numer r) (denom r)))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  'done)
(define (make-rational n d)
  ((get 'make 'rational) n d))

;; install-polynomial-package

(define (install-polynomial-package)
  ;; internal procedures
  (define (make-poly variable term-list)
    (cons variable (remove-zeros term-list)))
  (define (remove-zeros L)
    (filter (lambda (term) (not (=zero? (coeff term)))) L))
  (define (filter predicate sequence)
    (cond ((null? sequence) '())
          ((predicate (car sequence))
           (cons (car sequence)
                 (filter predicate (cdr sequence))))
          (else (filter predicate (cdr sequence)))))
  (define (variable p) (car p))
  (define (term-list p) (cdr p))
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
  ;; representation of terms and term lists
  (define (adjoin-term term term-list)
    (if (=zero? (coeff term))
        term-list
        (cons term term-list)))
  (define (the-empty-termlist) '())
  (define (first-term term-list) (car term-list))
  (define (rest-terms term-list) (cdr term-list))
  (define (empty-termlist? term-list) (null? term-list))
  (define (make-term order coeff) (list order coeff))
  (define (order term) (car term))
  (define (coeff term) (cadr term))

  (define (pseudoremainder-terms a b)
    (let* ((O1 (order (first-term a)))
           (O2 (order (first-term b)))
           (int-factor (expt (coeff (first-term b)) (+ 1 O1 (- O2)))))
      (let ((new-a (mul-term-by-all-terms
                    (make-term 0 int-factor) a)))
        (cadr (div-terms new-a b)))))
  (define (gcd-terms a b)
    (if (empty-termlist? b)
        (let* ((L (term-list a))
               (c-list (map (lambda (term) (coeff term)) L))
               (gcd-c-list (apply gcd c-list)))
          (map (lambda (term) (make-term (order term)
                                         (/ (coeff term) gcd-c-list)))
               a))
        (gcd-terms b (pseudoremainder-terms a b))))
  (define (gcd-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (gcd-terms (term-list p1)
                              (term-list p2)))
        (error "Polys not in same var -- GCD-POLY"
               (list p1 p2))))

  (define (add-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (add-terms (term-list p1)
                              (term-list p2)))
        (error "Polys not in same var -- ADD-POLY"
               (list p1 p2))))
  (define (add-terms L1 L2)
    (cond ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (else
           (let ((t1 (first-term L1)) (t2 (first-term L2)))
             (cond ((> (order t1) (order t2))
                    (adjoin-term
                     t1 (add-terms (rest-terms L1) L2)))
                   ((< (order t1) (order t2))
                    (adjoin-term
                     t2 (add-terms L1 (rest-terms L2))))
                   (else
                    (adjoin-term
                     (make-term (order t1)
                                (add (coeff t1) (coeff t2)))
                     (add-terms (rest-terms L1)
                                (rest-terms L2)))))))))
  (define (sub-poly p1 p2)
    (add-poly p1 (neg-poly p2)))
  (define (neg-poly p)
    (make-poly (variable p)
               (neg-terms (term-list p))))
  (define (neg-terms L)
    (if (empty-termlist? L)
        L
        (let ((t (first-term L)))
          (adjoin-term (make-term (order t) (negation (coeff t)))
                       (neg-terms (rest-terms L))))))
  (define (mul-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (mul-terms (term-list p1)
                              (term-list p2)))
        (error "Polys not in same var -- MUL-POLY"
               (list p1 p2))))
  (define (mul-terms L1 L2)
    (if (empty-termlist? L1)
        (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2)
                   (mul-terms (rest-terms L1) L2))))
  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
        (the-empty-termlist)
        (let ((t2 (first-term L)))
          (adjoin-term
           (make-term (+ (order t1) (order t2))
                      (mul (coeff t1) (coeff t2)))
           (mul-term-by-all-terms t1 (rest-terms L))))))
  (define (add-num-poly x p)
    (make-poly (variable p)
               (add-terms (list (make-term 0 x))
                          (term-list p))))
  (define (mul-num-poly x p)
    (make-poly (variable p)
               (map (lambda (term) (list (car term) (* x (cadr term))))
                    (term-list p))))
  (define (div-terms L1 L2)
    (if (empty-termlist? L1)
        (list (the-empty-termlist) (the-empty-termlist))
        (let ((t1 (first-term L1))
              (t2 (first-term L2)))
          (if (> (order t2) (order t1))
              (list (the-empty-termlist) L1)
              (let ((new-c (div (coeff t1) (coeff t2)))
                    (new-o (- (order t1) (order t2))))
                (let ((rest-of-result
                       (div-terms
                        (add-terms L1
                                   (neg-terms
                                    (mul-term-by-all-terms
                                     (make-term new-o new-c) L2)))
                        L2)))
                  (cons (adjoin-term (make-term new-o new-c)
                                     (car rest-of-result))
                        (cdr rest-of-result))))))))
  (define (div-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (let ((div-result (div-terms
                           (term-list p1)
                           (term-list p2))))
          (list
           (make-poly (variable p1) (car div-result))
           (make-poly (variable p2) (cadr div-result))))
        (error "Polys not in same var -- DIV-POLY"
               (list p1 p2))))
  (define (reduce-terms n d)
    (let ((g (gcd-terms n d)))
      (let ((O1 (max (order (first-term n))
                     (order (first-term d))))
            (O2 (order (first-term g))))
        (let ((int-factor (expt (coeff (first-term g))
                                (+ 1 O1 (- O2)))))
          (let ((new-n (mul-term-by-all-terms
                        (make-term 0 int-factor) n))
                (new-d (mul-term-by-all-terms
                        (make-term 0 int-factor) d)))
            (list (remove-factor (car (div-terms new-n g)))
                  (remove-factor (car (div-terms new-d g)))))))))
  (define (remove-factor L)
    (let ((c-list (map (lambda (term) (coeff term)) L)))
      (let ((gcd-c-list (apply gcd c-list)))
        (map (lambda (term)
               (make-term (order term)
                          (/ (coeff term) gcd-c-list)))
               L))))
  (define (reduce-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (let ((terms (reduce-terms (term-list p1)
                                   (term-list p2))))
          (list (make-poly (variable p1) (car terms))
                (make-poly (variable p2) (cadr terms))))
        (error "Polys not in the same var -- REDUCE-POLY"
               (list p1 p2))))

  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'polynomial x))
  (put 'add-poly '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'add-poly-num '(polynomial scheme-number)
       (lambda (p x) (tag (add-num-poly x p))))
  (put 'add-num-poly '(scheme-number polynomial)
       (lambda (x p) (tag (add-num-poly x p))))
  (put 'sub-poly '(polynomial polynomial)
       (lambda (p1 p2) (tag (sub-poly p1 p2))))
  (put 'neg-poly '(polynomial)
       (lambda (p) (tag (neg-poly p))))
  (put 'mul-poly '(polynomial polynomial)
       (lambda (p1 p2) (tag (mul-poly p1 p2))))
  (put 'mul-poly-num '(polynomial scheme-number)
       (lambda (p x) (tag (mul-num-poly x p))))
  (put 'mul-num-poly '(scheme-number polynomial)
       (lambda (x p) (tag (mul-num-poly x p))))
  (put 'div-poly '(polynomial polynomial)
       (lambda (p1 p2)
         (let ((div-result (div-poly p1 p2)))
           (list
            (tag (car div-result))
            (tag (cadr div-result))))))
  (put '=zero-poly? '(polynomial)
       (lambda (p) (empty-termlist? (term-list p))))
  (put 'make-poly 'polynomial
       (lambda (v t) (tag (make-poly v t))))
  (put 'gcd-poly '(polynomial polynomial)
       (lambda (p1 p2) (tag (gcd-poly p1 p2))))

  (put 'reduce '(polynomial polynomial)
       (lambda (p1 p2) 
         (let ((new-ps (reduce-poly p1 p2)))
           (list (tag (car new-ps)) 
                 (tag (cadr new-ps))))))
  (put 'make 'polynomial
       (lambda (var terms) (tag (make-poly var terms))))

  'done)

(define (make-polynomial var terms)
  ((get 'make 'polynomial) var terms))

(install-scheme-number-package)
(install-rational-package)
(install-polynomial-package)
