(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  false))
            false)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation - TABLE" m))))
    dispatch))

(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))

(define (put-coercion source-type target-type proc)
  (put 'coercion (list source-type target-type) proc))
(define (get-coercion source-type target-type)
  (get 'coercion (list source-type target-type)))

(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (let ((t1->t2 (get-coercion type1 type2))
                      (t2->t1 (get-coercion type2 type1)))
                  (cond (t1->t2
                         (apply-generic op (t1->t2 a1) a2))
                        (t2->t1
                         (apply-generic op a1 (t2->t1 a2)))
                        (else
                         (error "No method for these types"
                                (list op type-tags))))))
              (error "No method for these types"
                     (list op type-tags)))))))

(define (type-tag datum)
  (cond ((pair? datum) (car datum))
        ((number? datum) 'scheme-number)
        (else (error "Bad tagged datum -- TYPE-TAG" datum))))
(define (contents datum)
  (cond ((pair? datum) (cdr datum))
        ((number? datum) datum)
        (else (error "Bad tagged datum -- CONTENTS" datum))))
(define (attach-tag type-tag contents)
  (if (number? contents)
      contents
      (cons type-tag contents)))

(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (negation x) (apply-generic 'negation x))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (equ? x y) (apply-generic 'equ? x y))
(define (=zero? x) (apply-generic '=zero? x))

;; scheme number package
(define (install-scheme-number-package)
  (define (tag x)
    (attach-tag 'scheme-number x))    
  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'negation '(scheme-number)
       (lambda (x) (tag (- x))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'equ? '(scheme-number scheme-number) =)
  (put '=zero? '(scheme-number)
       (lambda (x) (= x 0)))
  (put 'make 'scheme-number
       (lambda (x) (tag x)))
  'done)
(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))

;; install-polynomial-package
(define (install-polynomial-package)
  ;; procedures 
  (define (make-dense-poly variable term-list)
    ((get 'make-poly 'dense) variable term-list))
  (define (make-sparse-poly variable term-list)
    ((get 'make-poly 'sparse) variable term-list))
  (define (add-poly p1 p2)
    (apply-generic 'add-poly p1 p2))
  (define (add-poly-num p x)
    (apply-generic 'add-poly-num p x))
  (define (add-num-poly x p)
    (apply-generic 'add-num-poly x p))
  (define (sub-poly p1 p2)
    (apply-generic 'sub-poly p1 p2))
  (define (neg-poly p)
    (apply-generic 'neg-poly p))
  (define (mul-poly p1 p2)
    (apply-generic 'mul-poly p1 p2))
  (define (mul-poly-num p x)
    (apply-generic 'mul-poly-num p x))
  (define (mul-num-poly x p)
    (apply-generic 'mul-num-poly x p))
  (define (=zero?-poly p)
    (apply-generic '=zero?-poly p))

  ;; interface to rest of the system
  (define (tag p) (attach-tag 'polynomial p))
  (put 'add '(polynomial polynomial)
       (lambda (p1 p2)
         (tag (add-poly p1 p2))))
  (put 'add '(polynomial scheme-number)
       (lambda (p x)
         (tag (add-poly-num 
               p (attach-tag 'scheme-number x)))))
  (put 'add '(scheme-number polynomial)
       (lambda (x p)
         (tag (add-num-poly
               (attach-tag 'scheme-number x) p))))
  (put 'sub '(polynomial polynomial)
       (lambda (p1 p2)
         (tag (add-poly p1 (neg-poly p2)))))
  (put 'sub '(polynomial scheme-number)
       (lambda (p x)
         (tag (add-poly-num 
               p 
               (negation (attach-tag 'scheme-number x))))))
  (put 'sub '(scheme-number polynomial)
       (lambda (x p)
         (tag (add-num-poly (attach-tag 'scheme-number x)
                            (neg-poly p)))))
  (put 'negation '(polynomial)
       (lambda (p) (tag (neg-poly p))))
  (put 'mul '(polynomial polynomial)
       (lambda (p1 p2)
         (tag (mul-poly p1 p2))))
  (put 'mul '(polynomial scheme-number)
       (lambda (p x)
         (tag (mul-poly-num p x))))
  (put 'mul '(scheme-number polynomial)
       (lambda (x p)
         (tag (mul-num-poly x p))))
  (put '=zero? '(polynomial)
       (lambda (p) (=zero?-poly p)))
  (put 'make-dense-polynomial 'polynomial 
       (lambda (variable term-list) 
         (tag (make-dense-poly variable term-list))))
  (put 'make-sparse-polynomial 'polynomial 
       (lambda (variable term-list) 
         (tag (make-sparse-poly variable term-list))))
  'done)

;; outside constructor
(define (make-dense-polynomial variable term-list)
  ((get 'make-dense-polynomial 'polynomial) variable term-list))
(define (make-sparse-polynomial variable term-list)
  ((get 'make-sparse-polynomial 'polynomial) variable term-list))

(define (install-dense-poly-package)
  (define (make-poly variable term-list)
    (cons variable (remove-leading-zeros term-list)))
  (define (remove-leading-zeros L)
    (cond ((null? L) '())
          ((=zero? (car L)) (remove-leading-zeros (cdr L)))
          (else L)))
  (define (variable p) (car p))
  (define (term-list p) (cdr p))
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
  ;; representation of terms and term lists
  (define (adjoin-term term term-list)
    (cond ((=zero? (coeff term)) term-list)
          ((= (order term) (length term-list))
           (cons (coeff term) term-list))
          (else (adjoin-term term (cons 0 term-list)))))
  (define (the-empty-termlist) '())
  (define (first-term L)
    (make-term (- (length L) 1) (car L)))
  (define (rest-terms term-list) (cdr term-list))
  (define (empty-termlist? term-list) (null? term-list))
  (define (make-term order coeff) (list order coeff))
  (define (order term) (car term))
  (define (coeff term) (cadr term))

  (define (add-poly p1 p2) 
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (add-terms (term-list p1)
                              (term-list p2)))
        (error "Polys not in same var -- ADD-POLY"
               (list p1 p2))))
  (define (add-terms L1 L2)
    (cond ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (else
           (let ((t1 (first-term L1)) (t2 (first-term L2)))
             (cond ((> (order t1) (order t2))
                    (adjoin-term
                     t1 (add-terms (rest-terms L1) L2)))
                   ((< (order t1) (order t2))
                    (adjoin-term
                     t2 (add-terms L1 (rest-terms L2))))
                   (else
                    (adjoin-term
                     (make-term (order t1)
                                (add (coeff t1) (coeff t2)))
                     (add-terms (rest-terms L1)
                                (rest-terms L2)))))))))
  (define (sub-poly p1 p2)
    (add-poly p1 (neg-poly p2)))
  (define (neg-poly p)
    (make-poly (variable p)
               (neg-terms (term-list p))))
  (define (neg-terms L)
    (if (empty-termlist? L)
        L
        (let ((t (first-term L)))
          (adjoin-term (make-term (order t) (negation (coeff t)))
                       (neg-terms (rest-terms L))))))
  (define (mul-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (mul-terms (term-list p1)
                              (term-list p2)))
        (error "Polys not in same var -- MUL-POLY"
               (list p1 p2))))
  (define (mul-terms L1 L2)
    (if (empty-termlist? L1)
        (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2)
                   (mul-terms (rest-terms L1) L2))))
  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
        (the-empty-termlist)
        (let ((t2 (first-term L)))
          (adjoin-term
           (make-term (+ (order t1) (order t2))
                      (mul (coeff t1) (coeff t2)))
           (mul-term-by-all-terms t1 (rest-terms L))))))
  (define (add-num-poly x p)
    (make-poly (variable p)
               (add-x-list x (term-list p))))
  (define (add-x-list x L)
    (cond ((empty-termlist? L) (list x))
          ((null? (cdr L)) (list (+ x (car L))))
          (else (cons (car L) (add-x-list x (cdr L))))))
  (define (mul-num-poly x p)
    (make-poly (variable p)
               (mul-x-list x (term-list p))))
  (define (mul-x-list x L)
    (map (lambda (y) (* x y)) L))
  (define (=zero-all-terms? L)
    (cond ((empty-termlist? L) #t)
          ((not (=zero? (coeff (first-term L)))) #f)
          (else (=zero-all-terms? (rest-terms L)))))
  (define (=zero-poly? p)
    (=zero-all-terms? (term-list p)))
  (define (sparse->dense p)
    (let ((s-p (contents p)))
      (let ((v (car s-p))
            (s-L (cdr s-p)))
        (let ((d-L (term-list-sparse->dense s-L)))
          (tag (make-poly v d-L))))))
  (define (term-list-sparse->dense s-L)
    (if (null? s-L)
        '()
        (let ((term (car s-L)))
          (let ((ord (car term))
                (coe (cadr term)))
            (adjoin-term 
             (make-term ord coe)
             (term-list-sparse->dense (cdr s-L)))))))

  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'dense x))
  (put 'add-poly '(dense dense)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'add-poly-num '(dense scheme-number)
       (lambda (p x) (tag (add-num-poly x p))))
  (put 'add-num-poly '(scheme-number dense)
       (lambda (x p) (tag (add-num-poly x p))))
  (put 'sub-poly '(dense dense)
       (lambda (p1 p2) (tag (sub-poly p1 p2))))
  (put 'neg-poly '(dense)
       (lambda (p) (tag (neg-poly p))))
  (put 'mul-poly '(dense dense)
       (lambda (p1 p2) (tag (mul-poly p1 p2))))
  (put 'mul-poly-num '(dense scheme-number)
       (lambda (p x) (tag (mul-num-poly x p))))
  (put 'mul-num-poly '(scheme-number dense)
       (lambda (x p) (tag (mul-num-poly x p))))
  (put '=zero?-poly '(dense) 
       (lambda (p) (empty-termlist? (term-list p))))
  (put 'make-poly 'dense
       (lambda (v t) (tag (make-poly v t))))
  (put-coercion 'sparse 'dense  sparse->dense)
  'done)

(define (install-sparse-poly-package)
  ;; internal procedures
  (define (make-poly variable term-list)
    (cons variable (remove-zeros term-list)))
  (define (remove-zeros L)
    (filter (lambda (term) (not (=zero? (coeff term)))) L))
  (define (filter predicate sequence)
    (cond ((null? sequence) '())
          ((predicate (car sequence))
           (cons (car sequence)
                 (filter predicate (cdr sequence))))
          (else (filter predicate (cdr sequence)))))
  (define (variable p) (car p))
  (define (term-list p) (cdr p))
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
  ;; representation of terms and term lists
  (define (adjoin-term term term-list)
    (if (=zero? (coeff term))
        term-list
        (cons term term-list)))
  (define (the-empty-termlist) '())
  (define (first-term term-list) (car term-list))
  (define (rest-terms term-list) (cdr term-list))
  (define (empty-termlist? term-list) (null? term-list))
  (define (make-term order coeff) (list order coeff))
  (define (order term) (car term))
  (define (coeff term) (cadr term))

  (define (add-poly p1 p2) 
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (add-terms (term-list p1)
                              (term-list p2)))
        (error "Polys not in same var -- ADD-POLY"
               (list p1 p2))))
  (define (add-terms L1 L2)
    (cond ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (else
           (let ((t1 (first-term L1)) (t2 (first-term L2)))
             (cond ((> (order t1) (order t2))
                    (adjoin-term
                     t1 (add-terms (rest-terms L1) L2)))
                   ((< (order t1) (order t2))
                    (adjoin-term
                     t2 (add-terms L1 (rest-terms L2))))
                   (else
                    (adjoin-term
                     (make-term (order t1)
                                (add (coeff t1) (coeff t2)))
                     (add-terms (rest-terms L1)
                                (rest-terms L2)))))))))
  (define (sub-poly p1 p2)
    (add-poly p1 (neg-poly p2)))
  (define (neg-poly p)
    (make-poly (variable p)
               (neg-terms (term-list p))))
  (define (neg-terms L)
    (if (empty-termlist? L)
        L
        (let ((t (first-term L)))
          (adjoin-term (make-term (order t) (negation (coeff t)))
                       (neg-terms (rest-terms L))))))
  (define (mul-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (mul-terms (term-list p1)
                              (term-list p2)))
        (error "Polys not in same var -- MUL-POLY"
               (list p1 p2))))
  (define (mul-terms L1 L2)
    (if (empty-termlist? L1)
        (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2)
                   (mul-terms (rest-terms L1) L2))))
  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
        (the-empty-termlist)
        (let ((t2 (first-term L)))
          (adjoin-term
           (make-term (+ (order t1) (order t2))
                      (mul (coeff t1) (coeff t2)))
           (mul-term-by-all-terms t1 (rest-terms L))))))
  (define (add-num-poly x p)
    (make-poly (variable p)
               (add-terms (list (make-term 0 x))
                          (term-list p))))
  (define (mul-num-poly x p)
    (make-poly (variable p)
               (map (lambda (term) (list (car term) (* x (cadr term))))
                    (term-list p))))

  (define (dense->sparse p)
    (let ((d-p (contents p)))
      (let ((v (car d-p))
            (d-L (cdr d-p)))
        (let ((s-L (term-list-dense->sparse d-L)))
          (tag (make-poly v s-L))))))
  (define (term-list-dense->sparse d-L)
    (if (null? d-L) 
        '()
        (let ((coe (car d-L))
              (ord (- (length d-L) 1)))
          (adjoin-term
           (make-term ord coe) 
           (term-list-dense->sparse (cdr d-L))))))

  ;; interface to the rest of the system
  (define (tag x) (attach-tag 'sparse x))
  (put 'add-poly '(sparse sparse)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'add-poly-num '(sparse scheme-number)
       (lambda (p x) (tag (add-num-poly x p))))
  (put 'add-num-poly '(scheme-number sparse)
       (lambda (x p) (tag (add-num-poly x p))))
  (put 'sub-poly '(sparse sparse)
       (lambda (p1 p2) (tag (sub-poly p1 p2))))
  (put 'neg-poly '(sparse)
       (lambda (p) (tag (neg-poly p))))
  (put 'mul-poly '(sparse sparse)
       (lambda (p1 p2) (tag (mul-poly p1 p2))))
  (put 'mul-poly-num '(sparse scheme-number)
       (lambda (p x) (tag (mul-num-poly x p))))
  (put 'mul-num-poly '(scheme-number sparse)
       (lambda (x p) (tag (mul-num-poly x p))))
  (put '=zero?-poly '(sparse) 
       (lambda (p) (empty-termlist? (term-list p))))
  (put 'make-poly 'sparse
       (lambda (v t) (tag (make-poly v t))))
  (put-coercion 'dense 'sparse dense->sparse)
  'done)


(install-scheme-number-package)
(install-polynomial-package)
(install-dense-poly-package)
(install-sparse-poly-package)
